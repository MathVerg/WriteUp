#!/usr/bin/python3

from pwn import *
import numpy as np
import sys
import heapq

sys.setrecursionlimit(int(1e6))
#context.log_level = 'debug'

HOST = "pwn.chall.pwnoh.io"
PORT = 13380

M = 2034
INF = float("inf")
TIMEOUT = 0


directions = {'a':(0, -1), 'w':(-1, 0), 's':(1, 0), 'd':(0, 1)}
opposite = {'a' : 'd', 'd' : 'a', 'w': 's', 's':'w'}
conditions = {'normal':0, 'frog':1, 'nebula':3, 'flag':5}
frog_warnings = ['ribbit', 'giggle', 'chirp']
nebula_warnings = ['light', 'dust', 'dense']

def parse_pos(text):
    coords = text.strip().split(" ")
    return (int(coords[0]), int(coords[-1]))

def manhattan(pos1, pos2):
    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

def apply_dir(pos, direction):
    return pos[0] + directions[direction][0], pos[1] + directions[direction][1]

class MazeSolver:
    def __init__(self, n):
        #self.p = process("./maze.py")
        self.p = remote(HOST, PORT)
        flag_coords_text = self.p.recvline().rstrip().decode()
        self.flag_coords = parse_pos(flag_coords_text)
        self.dimension = n
        self.maze = np.array([[{0, 1, 3} for _ in range(self.dimension)] for _ in range(self.dimension)])
        self.start = (self.dimension - 1, 0)
        newpos_text = self.p.recvline().rstrip().decode()
        if newpos_text[0] != "[" or newpos_text[-1] != "]" :
            print("Weird position :")
            print(newpos_text)
            exit(1)
        newpos = parse_pos(newpos_text[1:-1])
        assert newpos == self.start
        self.position = self.start
        self.maze[self.position] = {0}
        self.maze[self.flag_coords] = {5}
        self.flag_found = False
        
    def available_dirs(self, pos):
        y, x = pos
        dirs = set()
        if x > 0:
            dirs.add("a")
        if y > 0:
            dirs.add("w")
        if x < self.dimension - 1:
            dirs.add("d")
        if y < self.dimension - 1:
            dirs.add("s")
        return dirs

    def walkable(self, pos):
        status = self.maze[pos]
        return status == {5} or status == {0}

    def valid(self, temp_position):
        return temp_position[0] > -1 and temp_position[0] < self.dimension and temp_position[1] > -1 and temp_position[1] < self.dimension

    def walkable_neighbours(self, pos):
        dirs = self.available_dirs(pos)
        res = []
        for d in dirs:
            dst = apply_dir(pos, d)
            if self.walkable(dst):
                res.append((d, dst))
        return res

    def move(self, instruction):

        ### apply the move
        self.p.sendline(instruction.encode())

        temp = apply_dir(self.position, instruction)
        if self.valid(temp) == True:
            self.position = temp

        newpos_text = self.p.recvline().rstrip().decode()
        if newpos_text[0] != "[" or newpos_text[-1] != "]" :
            print("Weird position :")
            print(newpos_text)
            exit(1)
        newpos = parse_pos(newpos_text[1:-1])
        assert self.position == newpos
        
        ### receive the warnings
        warnings = {"frog": 0, "nebula":0}
        if self.maze[self.position] == {5}:
            self.p.recvline()
            self.flag_found = True
            print("flag found !")
        while self.p.can_recv(timeout=TIMEOUT):
            msg = self.p.recvline().rstrip().decode()
            if msg in frog_warnings:
                warnings["frog"] += 1
            elif msg in nebula_warnings:
                warnings["nebula"] += 1
            else :
                # note : this is not really clean code, but this branch will be taken when we receive the actual flag instead of a warning
                # so we can print the flag
                print("Unknown message :")
                print(msg)
                open("log.txt", "a").write(msg + "\n")
                assert False
        assert warnings["frog"] + warnings["nebula"] < 4


        if not self.visited[self.position]:
            self.visited[self.position] = True
        else :
            return

        ### remove the warnings that are redundant with the information we already have
        av_dirs = self.available_dirs(self.position)
        if not self.first_move:
            av_dirs.remove(opposite[instruction])
        for d in list(av_dirs):
            newpos = apply_dir(self.position, d)
            if self.walkable(newpos):
                av_dirs.remove(d)
            elif self.maze[newpos] == {1}:
                av_dirs.remove(d)
                assert warnings["frog"] > 0
                warnings["frog"] -= 1
            elif self.maze[newpos] == {3}:
                av_dirs.remove(d)
                assert warnings["nebula"] > 0
                warnings["nebula"] -= 1

        ### compute the possible values for the remaining adjacent tiles
        possibilities = {5}
        if warnings["frog"] + warnings["nebula"] < len(av_dirs):
            possibilities.add(0)
        if warnings["frog"] > 0:
            possibilities.add(1)
        if warnings["nebula"] > 0:
            possibilities.add(3)

        ### intersect this set of possible values with the adjacent tiles
        for d in av_dirs:
            newpos = apply_dir(self.position, d)
            newpos_possib = len(self.maze[newpos]) 
            if newpos_possib == 0:
                assert False
            if newpos_possib > 1 :
                old_possib = self.maze[newpos]
                self.maze[newpos] = self.maze[newpos].intersection(possibilities)
                newpos_possib = len(self.maze[newpos])
                if newpos_possib == 0:
                    print(self.maze)
                    print(old_possib)
                    print(possibilities)
                    print(instruction, newpos)
                    assert False
                if newpos_possib == 1:
                    #before that this tile had sevral possible candidates, now it has only one
                    self.updated = True
                    self.update_chunk(newpos)

        ### if we have only one warning that applies to tiles that are in the same chunk
        ### then the other tiles of the chunk are free
        if (warnings["frog"] == 1) ^ (warnings["nebula"] == 1):
            chunks = []
            av_pos = []
            if warnings["frog"] == 1 :
                number = 1
            else :
                number = 3
            for d in av_dirs:
                newpos = apply_dir(self.position, d)
                av_pos.append(newpos)
                y0, x0 = (newpos[0]//3)*3, (newpos[1]//3)*3
                chunks.append((y0, x0))
            if len(set(chunks)) == 1:
                y0, x0 = chunks[0]
                for i in range(y0, y0 + 3):
                    for j in range(x0, x0 + 3):
                        if (i, j) not in av_pos :
                            if number in self.maze[(i, j)] :
                                self.updated = True
                                self.maze[(i, j)].remove(number)

        ### after this processing, add the newly found free tiles to our exploration queue
        av_dirs = self.available_dirs(self.position)
        for d in av_dirs :
            newpos = apply_dir(self.position, d)
            if self.walkable(newpos) and not self.visited[newpos]:
                heapq.heappush(self.exploration_queue, (manhattan(newpos, self.flag_coords), newpos))
    
    def update_chunk(self, pos):

        ### gather all the tiles in the chunk of pos
        y, x = pos
        y0, x0 = (y//3)*3, (x//3)*3
        squares = []
        for i in range(y0, y0 + 3):
            for j in range(x0, x0 + 3):
                squares.append((i, j))

        ### count the different kind of tiles in our chunk
        flag_squares = 0
        free_squares = 0
        kill_squares = 0
        killing_square = None
        for p in squares:
            if self.maze[p] == {5}:
                flag_squares += 1
            elif self.maze[p] == {0}:
                free_squares += 1
            elif 0 not in self.maze[p]:
                kill_squares += 1
                killing_square = p
        assert flag_squares < 2
        assert kill_squares < 2
        
        ### if one tile contains a danger for sure, all the other tiles are free
        if kill_squares :
            for p in squares:
                if p != killing_square:
                    self.maze[p] = {0}
        
        ### if a chunk other than the spawn and flag chunk contains 8 free tiles, the last one is not free
        elif free_squares == 8 and flag_squares == 0 and self.start not in squares:
            for p in squares:
                if self.maze[p] != {0}:
                    self.maze[p].remove(0)

    def get_path(self, goal):
        assert self.walkable(goal)
        ### If the tile is adjacent, the path is trivial
        for (d, dst) in self.walkable_neighbours(self.position):
            if dst == goal:
                return [d]

        ### A*
        openSet = {self.position}
        cameFrom = {}
        gScore = {}
        gScore[self.position] = 0
        fScore = {}
        fScore[self.position] = manhattan(self.position, goal)
        while openSet != set():
            maxprio = INF
            for pos in openSet:
                if pos not in fScore:
                    fScore[pos] = INF
                if fScore[pos] < maxprio:
                    current = pos
                    maxprio = fScore[pos]
            if current == goal:
                path = []
                while current in cameFrom.keys():
                    d, current = cameFrom[current]
                    path.append(d)
                path.reverse()
                return path
            openSet.remove(current)
            neighbors = self.walkable_neighbours(current)
            for (d, neighbor) in neighbors:
                if neighbor not in gScore:
                    gScore[neighbor] = fScore[neighbor] = INF
                tentative_gScore = gScore[current] + 1
                if tentative_gScore < gScore[neighbor]:
                    cameFrom[neighbor] = (d, current)
                    gScore[neighbor] = tentative_gScore
                    fScore[neighbor] = tentative_gScore + manhattan(neighbor, goal)
                    if neighbor not in openSet:
                        openSet.add(neighbor)
        print(self.maze)
        print(self.visited)
        assert False

    def goto(self, goal):
        path = self.get_path(goal)
        for d in path :
            self.move(d)

    def explore(self):
        self.updated = True
        while self.updated:
            self.exploration_queue = []
            self.updated = False
            self.visited = np.full((self.dimension, self.dimension), False)
            self.first_move = True
            self.move("s")
            self.first_move = False
            while len(self.exploration_queue) > 0:
                _, goal = heapq.heappop(self.exploration_queue)
                if not self.visited[goal]:
                    self.goto(goal)
                if self.flag_found:
                    self.goto(self.start)
            self.goto(self.start)
        
    def win(self):
        self.explore()
        # remain of old strategy, left here just in case but the explore function alone should do the trick
        self.goto(self.flag_coords)
        self.goto(self.start)
        self.p.close()


try :
    m = MazeSolver(M)
    m.win()
except AssertionError:
    m.p.close()