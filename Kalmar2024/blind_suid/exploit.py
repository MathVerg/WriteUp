#!/usr/bin/python3

from pwn import *
import re
from tqdm import trange

HOST = "blind-suid.chal-kalmarc.tf"
PORT = 1337

U64_MASK = 0xffffffffffffffff

hashcash_regexp = r"^hashcash -mb28 [a-z0-9]{8}$"

def init_conn():
    global p
    p = remote(HOST, PORT)
    hashcash_cmd = p.recvline(keepends=False).decode()
    assert re.match(hashcash_regexp, hashcash_cmd)
    hashcash = process(hashcash_cmd, shell=True)
    hashcash.recvuntil(b"stamp: ")
    stamp = hashcash.recvline(keepends=False)
    hashcash.close()
    p.sendline(stamp)
    info(f"PoW solved")

def start():
    global p
    p.recvuntil(b"$ ")
    p.sendline(b"./minisudo")
    p.recvline()
    p.recvuntil(b"Password: ")

def explore_buf(depth:int):
    init_conn()
    for i in trange(depth):
        start()
        payload = b"A"*i
        p.sendline(payload)
        p.recvn(i)
        res = p.recvline()
        wrong_pass = p.recvline()
        if res != b"\r\n" or wrong_pass != b"Wrong password!\r\n":
            info(f"Interesting reult for {i=}: {res} {wrong_pass}")

def download_file(path:str, dest:str):
    p.recvuntil(b"$ ")
    p.sendline(b"base64 -w 0 "+path.encode())
    p.recvline()
    file_b64 = p.recvuntil(b"\x1b[01;", drop=True)
    with open(dest, "wb") as f:
        f.write(file_b64)

def dump_binary():
    with open("ptrace.c", "rb") as f:
        ptrace = f.read()
    ptrace_b64 = b64e(ptrace)
    p.recvuntil(b"$ ")
    p.sendline(f"echo {ptrace_b64} > /tmp/ptrace.b64".encode())
    p.recvuntil(b"$ ")
    p.recvuntil(b"$ ")
    p.sendline(b"base64 -d /tmp/ptrace.b64 > /tmp/ptrace.c")
    p.recvuntil(b"$ ")
    p.recvuntil(b"$ ")
    p.sendline(b"gcc -Wall -Wextra -o /tmp/ptrace /tmp/ptrace.c")
    p.recvuntil(b"$ ")
    p.recvuntil(b"$ ")
    p.sendline(b"/tmp/ptrace ./minisudo 2> /tmp/dump")
    p.recvline()
    p.recvuntil(b"Password: ")
    p.sendline(b"hello")
    p.recvuntil(b"$ ")
    download_file("/tmp/dump", "true_dump.b64")

def mangle(num:int, shift: int, left:bool) -> int:
    if left:
        return num ^ ((num  << shift) & U64_MASK)
    else:
        return num ^ (num  >> shift)

def unmangle(num: int, shift:int, left:bool) -> int:
    """
    reverse operations like h = h ^ (h >> shift) on 64 bits
    """
    real = 0
    num_correct = 0
    while num_correct < 64:
        mask_len = min(shift, 64-num_correct)
        mask = (1 << mask_len) - 1
        if left:
            mask <<= num_correct
            real |= (num ^ (real << shift) ) & mask

        else:
            mask <<= (64-num_correct - mask_len)
            real |= (num ^ (real >> shift) ) & mask
        num_correct += shift
        #print(hex(real), bin(mask))
    return real & U64_MASK
        

def unhash(h:int) -> bytes:
    for i in range(0x10):
        h = unmangle(h, 0x1b, False)
        h = unmangle(h, 0x19, True)
        h = unmangle(h, 0xc, False)
    print(f"After demangling: {hex(h)}")
    h = ror(h, 0x14, 64)
    h ^= 0xaaaaaaaaaaaaaaaa
    cmd = []
    while h > 1:
        c = h % 26
        cmd.append(ord('a') + c)
        h //= 26
    if h != 1:
        print("Error: unhash failed")
    cmd.reverse()
    return bytes(cmd)
        

def hash(cmd:bytes) -> int:
    h = 1
    for c in cmd:
        h *= 0x1a
        if (ord('@') < c) and (c < ord('[')):
            h += (c - 0x41)
        elif (ord('`') < c) and (c < ord('{')):
            h += (c - 0x61)
    h = h & U64_MASK
    h ^= 0xaaaaaaaaaaaaaaaa
    h = rol(h, 0x14, 64)
    print(f"Before mangling: {hex(h)}")
    for i in range(0x10):
        h = mangle(h, 0xc, False)
        h = mangle(h, 0x19, True)
        h = mangle(h, 0x1b, False)
    return h


print(unhash(0x39403f5da078c2a))

